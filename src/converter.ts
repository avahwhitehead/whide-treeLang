import { BinaryTree } from "./types/Trees";
import { ConversionTree, ChoiceType, ListType, TreeType } from "./parser";
import ConverterException from "./exceptions/ConverterException";

//========
// Utils
//========

/**
 * Convert a tree to a number.
 * Returns undefined if the number is not strictly a valid number (i.e. the left node is not `null` at any point)
 * @param tree	The tree to interpret
 * @param cur	The starting value (default 0)
 * @returns the number represented by the tree, or `undefined` if not available
 */
function _readNumber(tree: BinaryTree, cur = 0): number|undefined {
	if (tree === null) return cur;
	if (tree.left !== null) return undefined;
	return _readNumber(tree.right, cur + 1);
}

//========
// AtomTypes
//========

/**
 * Check a tree against an atom string (e.g. 'nil'/'any'/'int')
 * @param tree	The tree to check
 * @param atom	The atomic string to check against
 */
function _convertAtom(tree: BinaryTree, atom: string): boolean {
	//Built-in types
	switch (atom) {
		case 'nil':
			//The tree node must be null
			return tree === null;
		case 'any':
			//Any tree is valid
			return true;
		case 'int':
			//Only numbers are valid
			return (_readNumber(tree) !== undefined);
		default:
			//Can't check against unknown types
			return false;
	}
}

//========
// Converters
//========

/**
 * Check the tree against a conversion tree 'choice' node
 * @param tree				The tree to check
 * @param conversionTree	The conversion tree node
 */
function _convertChoice(tree: BinaryTree, conversionTree: ChoiceType): boolean {
	for (let type of conversionTree.type) {
		let res: boolean;

		if (typeof type === "string") res = _convertAtom(tree, type);
		else res = _convert(tree, type);

		if (res) return true;
	}
	return false;
}

/**
 * Check the tree against a conversion tree 'tree' node
 * @param tree				The tree to check
 * @param conversionTree	The conversion tree node
 */
function _convertTree(tree: BinaryTree, conversionTree: TreeType): boolean {
	//An empty tree can't match a TreeType node
	if (tree == null) return false;
	//Check the left and right sides match
	return _convert(tree.left, conversionTree.left) && _convert(tree.right, conversionTree.right)
}

/**
 * Check the tree against a conversion tree 'list' node
 * @param tree				The tree to check
 * @param conversionTree	The conversion tree node
 */
function _convertList(tree: BinaryTree, conversionTree: ListType): boolean {
	//Null trees match with empty lists
	if (tree === null) return true;
	//Check the left node matches with the acceptable types
	//Check the right node is a list of this same type
	return _convert(tree.left, conversionTree.type) && _convertList(tree.right, conversionTree);
}

//========
// General
//========

/**
 * Read the type of the conversion tree's root node, and convert the tree accordingly
 * @param tree				The tree to check
 * @param conversionTree	The conversion tree node
 */
function _convert(tree: BinaryTree, conversionTree: ConversionTree): boolean {
	const category = conversionTree.category;
	switch (category) {
		case "choice":
			return _convertChoice(tree, (conversionTree as ChoiceType));
		case "list":
			return _convertList(tree, (conversionTree as ListType));
		case "tree":
			return _convertTree(tree, (conversionTree as TreeType));
		default:
			throw new ConverterException(`Unknown branch type: '${category}'`);
	}
}

/**
 * Match a binary tree against a given conversion tree
 * @param tree				The tree to convert
 * @param conversionTree	The conversion tree to use (should be generated by the `parser`)
 */
export default function runConvert(tree: BinaryTree, conversionTree: ConversionTree) : boolean {
	//TODO: Return a proper match tree, not a boolean
	return _convert(tree, conversionTree);
}
